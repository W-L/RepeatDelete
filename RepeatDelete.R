library(data.table)
library(ggplot2)
library(dplyr)
library(forcats)
library(scales)

# this script makes a plot of fragments that align to a consensus of a TE
# the input is a file generated by RepeatMasker
# run Repeatmasker with -xm and use the resulting .out.xm file!
# example RepeatMasker command:
# RepeatMasker -pa 4 -s -nolow -norna -div 20 -lib LIBRARY -u -xm ASSEMBLY

# SET PARAMETERS AND OPTIONS   ##############################
setwd('~/Desktop/multiIDs/RepeatDelete/')
input <- "./r6_hobo.out.xm"
output <- './hobo_in_r6_new.pdf'
max_divergence <- 20
min_fragment_len <- 100
max_inter_fragment_distance <- 100
color_divergence <- TRUE
TE_len <- 2959


#############################################################


# read the input file
TE <- fread(cmd=paste("cat", input, "| tr '*' ' '"))

# rename some variables and cast variable types into factors
TE_rename <- TE %>% 
  select(divergence=V2, del=V3, chrom=V5, chrStart=V6, chrEnd=V7, strand=V9, V11, V12, V13) %>% 
  mutate(chrom=as.factor(chrom), strand=as.factor(strand))

# commented part is to rename the chromosomes in a4 assembly
# also filters for the main chromosomes for the r6 assembly
# comment out the filtering if used with a4, and vice versa
TE_rename <- TE_rename %>% 
  # mutate(chrom = forcats::fct_recode(chrom, 'X' = 'CM008268.1', '2L' = 'CM008269.1',
  #                                    '2R' = 'CM008270.1', '3L' = 'CM008271.1',
  #                                    '3R' = 'CM008272.1', '4' = 'CM008273.1')) %>% 
  filter(chrom %in% c('2L','2R','3L','3R','X'))


# separate the dataframes into the two strands 
# because the columns for start and end of the TE are different for the strands
TE_plus <- TE_rename %>% 
  filter(strand=='+') %>%
  rename(elementStart=V11, elementEnd=V12) %>% 
  select(-V13) %>% 
  mutate(elementStart=as.numeric(elementStart))

TE_minus <- TE_rename %>% 
  filter(strand=='C') %>% 
  rename(elementStart=V13, elementEnd=V12) %>% 
  select(-V11) %>% 
  mutate(elementStart=as.numeric(elementStart))

# merge the two stranded dataframes again
TEs <- bind_rows(TE_plus, TE_minus)


# calc sizes of the fragment on the chromosome
# and the size of the covered part of the TE
# filter the fragments by a minimum size and maximum divergence
# also add grouping by chromosome and strand
TEs_group <- TEs %>% 
  mutate(chrSize=chrEnd-chrStart, elementSize=elementEnd-elementStart, sizeDiff=elementSize-chrSize) %>%
  filter(elementSize > min_fragment_len) %>% 
  filter(divergence < max_divergence) %>% 
  group_by(chrom, strand)

# in the repeatmasker output the fragments are ordered by their 
# coordinates on the chromosomes
# this function determines whether two fragments should be placed 
# on the same line in the plot, i.e. whether they stem from the same insertion
# it compares two rows in a dataframe and distinguishes between the strandedness
compRows <- function(currRow, nextRow){
  if (currRow$strand == '+'){
    if (currRow$chrEnd + max_inter_fragment_distance > nextRow$chrStart & currRow$elementEnd < nextRow$elementStart){
      return(1)
    } else {
      return(0)
    }
  }
  else {
    if (currRow$chrEnd + max_inter_fragment_distance > nextRow$chrStart & currRow$elementEnd > nextRow$elementStart){
      return(1)
    } else {
      return(0)
    }
  }
}


# function to check whether two fragments on the same line are actual IDs 
# or separated by an inserted sequence
# returns the values necessary for plotting of line denoting true IDs
# thats: coordinates on x-axis between fragments, coordinate on y, and chrom for facet
checkID <- function(currRow, nextRow){
  if (abs(nextRow$chrStart - currRow$chrEnd) < 10) { 
    return(list(currRow$elementEnd, nextRow$elementStart, 
             currRow$id_stranded, as.character(currRow$chrom)))
    } else {return(0)}
}


# this function runs the function above on the grouped dataframe
# the column 'id' that is created here determines whether two fragments
# are on the same line in the plot. And additionally determines 
# their placement on the y-axis by incrementing them after every separate insertion
findIDs <- function(curr){
  # start the 'id' column with a 1
  curr[1, 'id'] <- 1
  # if the current dataframe has only one entry, just return it
  if (nrow(curr)==1){return(curr)}
  # loop over all rows except for the last one
  for (i in 1:(nrow(curr) - 1)){
    # compare the current and the next row
    # if compRows returns a 1 (fragment from same insertion), then
    # both rows get the same 'id'
    if (compRows(curr[i,], curr[i+1,]) == 1){
      curr[i + 1, 'id'] <- curr[i, 'id']
    } else {curr[i + 1, 'id'] <- curr[i, 'id'] + 1}
  }
  return(curr)
}


# runs the function checkID over all rows in the grouped data frames
realIDs <- function(curr){
  ids <- data.frame(NULL)
  if (nrow(curr) == 1){return(NULL)}
  for (i in 1:(nrow(curr) - 1)){
    res <- checkID(curr[i,], curr[i+1,])
    if (res[1] != 0){
      ids <- rbind(ids, res)
    }
  }
  return(ids)
}



# The two functions get applied here
# first split the dataframe (grouped by chromosome and strand)
# apart to apply the function
groups <- group_split(TEs_group)
groups_id <- lapply(groups, findIDs)
# then merge them again
TE_id <- bind_rows(groups_id)
# for the fragments that are complementary, the 'id'
# gets converted to negative number, so that they are plotted 
# below the element on the plot
TE_id <- TE_id %>% mutate(id_stranded = ifelse(strand=='+', id, -id))

# apply the function that checks whether gaps between fragments
# are from an ID
# group and split the dataframe by 'id' and 'chrom'
ids <- lapply(group_split(TE_id %>% group_by(chrom, id)), realIDs)
# get rid of useless list entries
ids[sapply(ids, is.null)] <- NULL
ids[sapply(ids, function(x){ifelse(nrow(x) == 0, T, F)})] <- NULL
# bind the return values from the list into one data frame
ids <- rbindlist(ids, use.names = F)
names(ids) <- c('start', 'end', 'y', 'chrom')


# here a custom color gradient is created for the values of divergence
# we need to do this outside of ggplot because the fragments are plotted as
# geom_segment and those do not seem to understand a color aesthetic
cc <- scales::seq_gradient_pal("grey", "red", "Lab")(seq(0,1,length.out=max_divergence * 10))


# finally create the plot
p <- ggplot(TE_id, aes(group=chrom)) +
  # set x axis to the length of the TE
  scale_x_continuous(limits=c(0, TE_len)) +
  # set y axis to min/max number of elements on a single chromosome
  scale_y_continuous(limits=c(min(TE_id$id_stranded), max(TE_id$id_stranded))) +
  geom_blank() +
  # facet by chromosomes
  facet_wrap(.~chrom) +
  # there points are only added to create the legend, they are not actually plotted
  geom_point(aes(x=chrStart, y=id_stranded, color=divergence), data=TE_id) +
  scale_color_gradient(low='grey', high='red', name='divergence (%)') +
  # this is the segment for the hobo element in the center
  geom_segment(x=0, xend=TE_len, y=0, yend=0, size=2) +
  # add segments for the 'true' ids
  geom_segment(x=ids$start, xend=ids$end, y=ids$y, yend=ids$y, data=ids, size=0.5) +
  
  # remove lots of stuff from the theme to make it look nice
  theme_minimal() +
  theme(axis.title = element_blank(), axis.text = element_blank(),
        axis.ticks = element_blank(), panel.grid = element_blank(),
        panel.border = element_rect(fill=NA))


# now plot all the fragments found by RepeatMasker, 
# x values are the positions of the elements, y values are the 'id' determined above
# and color gets assigned with the gradient we created above, if color_divergence == T
# otherwise they are just grey.. and the legend gets removed
if (color_divergence == T){ 
  p <- p + geom_segment(x=TE_id$elementStart, xend=TE_id$elementEnd, 
                        y=TE_id$id_stranded, yend=TE_id$id_stranded, data=TE_id, size=2,
                        color=cc[TE_id$divergence * 10 + 1])
} else {
  p <- p + geom_segment(x=TE_id$elementStart, xend=TE_id$elementEnd, 
                        y=TE_id$id_stranded, yend=TE_id$id_stranded, data=TE_id, size=2,
                        color='grey') + theme(legend.position = "none")
}


# these lines add the labels of the positions of the fragments on the chromosomes
# can be commented out
p <- p + geom_text(data=TE_id %>% filter(strand=='+'), 
            aes(x=elementStart, y=id_stranded, label=chrStart), size=1, angle=25) +
         geom_text(data=TE_id %>% filter(strand=='+'),
            aes(x=elementEnd, y=id_stranded, label=chrEnd), size=1, angle=25) +
         geom_text(data=TE_id %>% filter(strand=='C'), 
            aes(x=elementStart, y=id_stranded, label=chrEnd), size=1, angle=25) +
         geom_text(data=TE_id %>% filter(strand=='C'), 
            aes(x=elementEnd, y=id_stranded, label=chrStart), size=1, angle=25)


# save the plot
ggsave(filename=output, plot=p, width = 10, height = 8)

