library(data.table)
library(ggplot2)
library(dplyr)
library(forcats)
library(scales)

# this script makes a plot of fragments that align to a consensus of a TE
# the input is a file generated by RepeatMasker
# run Repeatmasker with -xm and use the resulting .out.xm file!!!!

# mark, count and quantify real IDs

input <- "~/Desktop/multiIDs/r6/r6_hobo.out.xm"
output <- '~/Desktop/multiIDs/r6/hobo_in_r6_new.pdf'
max_divergence <- 20
min_fragment_len <- 100
max_inter_fragment_distance <- 100
color_divergence <- TRUE


# read the input file
TE_len <- 2959
TE <- fread(cmd=paste("cat", input, "| tr '*' ' '"))

# rename some variables and cast variable types into factors
TE_rename <- TE %>% 
  select(divergence=V2, del=V3, chrom=V5, chrStart=V6, chrEnd=V7, strand=V9, V11, V12, V13) %>% 
  mutate(chrom=as.factor(chrom), strand=as.factor(strand))

# this renames the chromosomes of the a4 assembly
# and filters for the main chromosomes for the r6 assembly
# no action required, works for both
TE_rename <- TE_rename %>% 
  mutate(chrom = forcats::fct_recode(chrom, 
          'X' = 'CM008268.1',
          '2L' = 'CM008269.1',
          '2R' = 'CM008270.1',
          '3L' = 'CM008271.1',
          '3R' = 'CM008272.1',
          '4' = 'CM008273.1')) %>% 
  filter(chrom %in% c('2L','2R','3L','3R','X'))


# separate the dataframes into the two strands 
# because the columns for start and end of the TE are different for the strands
TE_plus <- TE_rename %>% 
  filter(strand=='+') %>%
  rename(elementStart=V11, elementEnd=V12) %>% 
  select(-V13) %>% 
  mutate(elementStart=as.numeric(elementStart))

TE_minus <- TE_rename %>% 
  filter(strand=='C') %>% 
  rename(elementStart=V13, elementEnd=V12) %>% 
  select(-V11) %>% 
  mutate(elementStart=as.numeric(elementStart))

# merge the two stranded dataframes again
TEs <- bind_rows(TE_plus, TE_minus)


# calc sizes of the fragment on the chromosome
# and the size of the covered part of the TE
# filter the fragments by a minimum size and maximum divergence
# also add grouping by chromosome and strand
TEs_group <- TEs %>% 
  mutate(chrSize=chrEnd-chrStart, elementSize=elementEnd-elementStart, sizeDiff=elementSize-chrSize) %>%
  filter(elementSize > min_fragment_len) %>% 
  filter(divergence < max_divergence) %>% 
  group_by(chrom, strand)

# in the repeatmasker output the fragments are ordered by their 
# coordinates on the chromosomes
# this function determines whether two fragments should be placed 
# on the same line in the plot, i.e. whether they stem from the same insertion
# it compares two rows in a dataframe and distinguishes between the strandedness
compRows <- function(currRow, nextRow){
  if (currRow$strand == '+'){
    if (currRow$chrEnd + max_inter_fragment_distance > nextRow$chrStart & currRow$elementEnd < nextRow$elementStart){
      return(1)
    } else {
      return(0)
    }
  }
  else {
    if (currRow$chrEnd + max_inter_fragment_distance > nextRow$chrStart & currRow$elementEnd > nextRow$elementStart){
      return(1)
    } else {
      return(0)
    }
  }
}


# this function runs the function above on the grouped dataframe
# the column 'id' that is created here determines whether two fragments
# are on the same line in the plot. And additionally determines 
# their placement on the y-axis by incrementing them after every separate insertion
findIDs <- function(curr){
  # start the 'id' column with a 1
  curr[1, 'id'] <- 1
  # if the current dataframe has only one entry, just return it
  if (nrow(curr)==1){return(curr)}
  # loop over all rows except for the last one
  for (i in 1:(nrow(curr) - 1)){
    # compare the current and the next row
    # if compRows returns a 1 (fragment from same insertion), then
    # both rows get the same 'id'
    if (compRows(curr[i,], curr[i+1,]) == 1){
      curr[i + 1, 'id'] <- curr[i, 'id']
    } else {curr[i + 1, 'id'] <- curr[i, 'id'] + 1}
  }
  return(curr)
}


# The two functions get applied here
# first split the dataframe (grouped by chromosome and strand)
# apart to apply the function
groups <- group_split(TEs_group)
groups_id <- lapply(groups, findIDs)
# then merge them again
TE_id <- bind_rows(groups_id)

# for the fragments that are complementary, the 'id'
# gets converted to negative number, so that they are plotted 
# below the element on the plot
TE_id <- TE_id %>% mutate(id_stranded = ifelse(strand=='+', id, -id))

# here a custom color gradient is created for the values of divergence
# we need to do this outside of ggplot because the fragments are plotted as
# geom_segment and those do not seem to understand a color aesthetic
cc <- scales::seq_gradient_pal("grey", "red", "Lab")(seq(0,1,length.out=max_divergence * 10))


# finally create the plot
p <- ggplot(TE_id, aes(group=chrom)) +
  # set x axis to the length of the TE
  scale_x_continuous(limits=c(0, TE_len)) +
  # set y axis to min/max number of elements on a single chromosome
  scale_y_continuous(limits=c(min(TE_id$id_stranded), max(TE_id$id_stranded))) +
  geom_blank() +
  # facet by chromosomes
  facet_wrap(.~chrom) +
  # there points are only added to create the legend, they are not actually plotted
  geom_point(aes(x=chrStart, y=id_stranded, color=divergence), data=TE_id) +
  scale_color_gradient(low='grey', high='red', name='divergence (%)') +
  # this is the segment for the hobo element in the center
  geom_segment(x=0, xend=TE_len, y=0, yend=0, size=2) +
  
  # these lines add the labels of the positions of the fragments on the chromosomes
  geom_text(data=TE_id %>% filter(strand=='+'), 
    aes(x=elementStart, y=id_stranded, label=chrStart), size=1, angle=25) +
  geom_text(data=TE_id %>% filter(strand=='+'),
    aes(x=elementEnd, y=id_stranded, label=chrEnd), size=1, angle=25) +
  geom_text(data=TE_id %>% filter(strand=='C'), 
    aes(x=elementStart, y=id_stranded, label=chrEnd), size=1, angle=25) +
  geom_text(data=TE_id %>% filter(strand=='C'), 
    aes(x=elementEnd, y=id_stranded, label=chrStart), size=1, angle=25) +
  # remove lots of stuff from the theme to make it look nice
  theme_minimal() +
  theme(axis.title = element_blank(), axis.text = element_blank(),
        axis.ticks = element_blank(), panel.grid = element_blank(),
        panel.border = element_rect(fill=NA))


# now plot all the fragments found by RepeatMasker, 
# x values are the positions of the elements, y values are the 'id' determined above
# and color gets assigned with the gradient we created above, if color_divergence == T
# otherwise they are just grey.. and the legend gets removed
if (color_divergence == T){ 
  p <- p + geom_segment(x=TE_id$elementStart, xend=TE_id$elementEnd, 
                        y=TE_id$id_stranded, yend=TE_id$id_stranded, data=TE_id, size=2,
                        color=cc[TE_id$divergence * 10 + 1])
} else {
  p <- p + geom_segment(x=TE_id$elementStart, xend=TE_id$elementEnd, 
                        y=TE_id$id_stranded, yend=TE_id$id_stranded, data=TE_id, size=2,
                        color='grey') + theme(legend.position = "none")
}

# save the plot
ggsave(filename=output, plot=p, width = 10, height = 8)

